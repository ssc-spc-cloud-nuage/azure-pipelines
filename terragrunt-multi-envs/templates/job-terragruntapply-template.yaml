parameters:
  - name: layers
    type: object
  - name: serviceConnection
    type: string
  - name: eslzEnvFolder
    type: string
  - name: eslzEnvPool
    type: string
  - name: multiRunID
    type: string
  - name: terraformVersion
    type: string
  - name: terragruntVersion
    type: string

jobs:
- ${{ each layer in parameters.layers }}:  
  - deployment: TerragruntApply_${{ parameters.eslzEnvFolder}}_${{ layer }}
    condition: and(succeeded(), eq(stageDependencies.${{ parameters.eslzEnvFolder }}_Plan_${{ parameters.multiRunID }}.InitJob.outputs['GitDiffTask.RepoChange${{ layer }}'], 'true'))
    environment: ${{ parameters.eslzEnvFolder}}
    pool: 
      name: ${{ parameters.eslzEnvPool}}
    strategy:
      runOnce:
        deploy:
          steps:
            - download: none
            - bash: |
                if [ ! -d "$(Agent.ToolsDirectory)/.tfenv" ]; then
                git clone --depth=1 https://github.com/ssc-spc-cloud-nuage/tfenv.git $(Agent.ToolsDirectory)/.tfenv
                echo 'export PATH=$(Agent.ToolsDirectory)/.tfenv/bin:$PATH' >> ~/.profile
                $(Agent.ToolsDirectory)/.tfenv/bin/tfenv install ${{ parameters.terraformVersion }}
                $(Agent.ToolsDirectory)/.tfenv/bin/tfenv use ${{ parameters.terragruntVersion }}
                fi

                if [ ! -d "$(Agent.ToolsDirectory)/.tgenv" ]; then
                git clone --depth=1 https://github.com/ssc-spc-cloud-nuage/tgenv.git $(Agent.ToolsDirectory)/.tgenv
                echo 'export PATH=$(Agent.ToolsDirectory)/.tgenv/bin:$PATH' >> ~/.profile
                $(Agent.ToolsDirectory)/.tgenv/bin/tgenv install 0.66.9
                $(Agent.ToolsDirectory)/.tgenv/bin/tgenv use 0.66.9
                fi

                source ~/.profile
            
              displayName: 'install terraform/terragrunt'
            # - task: DownloadBuildArtifacts@1
            #   name: DownloadTF
            #   inputs:
            #     buildType: current
            #     downloadType: single
            #     artifactName: tf_${{ parameters.eslzEnvFolder}}_${{ layer }}
            #     downloadPath: '$(Build.SourcesDirectory)'
            - task: DownloadBuildArtifacts@1
              name: DownloadPlan
              inputs:
                buildType: current
                downloadType: single
                artifactName: plan_${{ parameters.eslzEnvFolder}}_${{ layer }}
                downloadPath: '$(Agent.TempDirectory)'
            - task: AzureCLI@2
              displayName: 'terragrunt apply'
              inputs:
                azureSubscription: ${{ parameters.serviceConnection }}
                scriptType: bash
                scriptLocation: inlineScript
                addSpnToEnvironment: true
                failOnStandardError : false
                visibleAzLogin: false
                inlineScript: |
                  set -e
                  export ARM_CLIENT_ID=$servicePrincipalId
                  export ARM_OIDC_TOKEN=$idToken
                  export ARM_TENANT_ID=$tenantId
                  export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
                  export ARM_USE_OIDC=true
                  export PIPELINE_TOKEN=$(az account get-access-token --resource 499b84ac-1321-427f-aa17-267ca6975798 --query "accessToken" --output tsv)
                  export TERRAGRUNT_PIPELINE_RUN=true
                  export instrumentationKey=$(az keyvault secret show --id https://g3scckv-cpms-mma-f07c-kv.vault.azure.net/secrets/instkey/a68523ce6abf4d77addf4cfbc247fbd1 --query value -o tsv)
                  export apiKey=$(az keyvault secret show --id https://g3scckv-cpms-mma-f07c-kv.vault.azure.net/secrets/G3Sc-CPMS-MMahdavian-app-insights-appi-api-key/59750d02a3bc498abcf7e30d4d01e936 --query value -o tsv)

                  echo "##vso[task.setvariable variable=instrumentationKey;issecret=true]$instrumentationKey"
                  echo "##vso[task.setvariable variable=apiKey;issecret=true]$apiKey"

                  cd $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/${{ layer }}/
                  terragrunt apply -auto-approve $(Agent.TempDirectory)/plan_${{ parameters.eslzEnvFolder}}_${{ layer }}/plan.tfplan

                  applyExitCode=$?
                  
                  echo "##vso[task.setvariable variable=applyExitCode;issecret=true]$applyExitCode"

              env:
                SYSTEM_ACCESSTOKEN: $(System.AccessToken)

            - task: bash@3
              name: LogApply
              condition: succeededOrFailed()
              inputs:
                targetType: inline
                script: |
                  set - e
                  # Define input parameters
                  appId="$INSTRUMENTATION_KEY"
                  apiKey="$API_KEY"
                  eventName="Terragrunt Apply $(System.TeamProject) ${{ layer }}"
                  pipelineName="$(Build.DefinitionName)"
                  buildNumber="$(Build.BuildNumber)"
                  org="$(System.CollectionUri)"
                  project="$(System.TeamProject)"
                  fullURL="$org$project"
                  run="$fullURL/_build/results?buildId=$(Build.BuildId)"
                  subscription_id=$(grep -Po '^\s*subscription_id\s*=\s*"\K[^"]+' $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/config.hcl)                  

                  if [ $APPLY_EXIT_CODE -eq 0 ]; then
                    tfOutput="Successful Apply"
                  else
                    tfOutput="Error in Apply"
                  fi
                  
                  echo $tfOutput

                  # Set headers for the HTTP request
                  headers=(
                      -H "Content-Type: application/json"
                      -H "X-Api-Key: $apiKey"
                  )

                  # Set the body of the HTTP request
                  body=$(jq -n \
                    --arg appId "$appId" \
                    --arg eventName "$eventName" \
                    --arg pipelineName "$pipelineName" \
                    --arg buildNumber "$buildNumber" \
                    --arg subID "$subscription_id" \
                    --arg project "$fullURL" \
                    --arg runID "$run" \
                    --arg tfOutput "$tfOutput" \
                    --arg time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
                    '{
                      name: "Microsoft.ApplicationInsights.Event",
                      time: $time,
                      iKey: $appId,
                      data: {
                        baseType: "EventData",
                        baseData: {
                          name: $eventName,
                          properties: {
                            PipelineName: $pipelineName,
                            BuildNumber: $buildNumber,
                            subID: $subID,
                            project: $project,
                            runID: $runID,
                            TFOutput: $tfOutput
                          }
                        }
                      }
                    }')

                  # Define the URI for the telemetry event
                  uri="https://dc.services.visualstudio.com/v2/track"

                  # Make the HTTP POST request
                  response=$(curl -s -X POST "${headers[@]}" -d "$body" "$uri")

                  # Check if the response was successful
                  if [ $? -eq 0 ]; then
                    echo "Response: $response"
                  else
                    echo "Failed to send telemetry"
                  fi
              env:
                INSTRUMENTATION_KEY: $(instrumentationKey)
                API_KEY: $(apiKey)
                APPLY_EXIT_CODE: $(applyExitCode)
