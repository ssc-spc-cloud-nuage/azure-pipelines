parameters:
  - name: layers
    type: object
  - name: serviceConnection
    type: string
  - name: eslzEnvFolder
    type: string
  - name: checkovSkipChecks
    type: string
  - name: eslzEnvPool
    type: string


jobs:
- ${{ each layer in parameters.layers }}:  
  - job: TerragruntPlan_${{ parameters.eslzEnvFolder}}_${{ layer }}
    dependsOn: InitJob
    condition: and(succeeded(), eq(dependencies.InitJob.outputs['GitDiffTask.RepoChange${{ layer }}'], 'true'))
    variables:
      AgentName: $[ dependencies.InitJob.outputs['InstallTools.JobAgentName'] ]
    pool: 
      name: ${{ parameters.eslzEnvPool }}
      demands: Agent.Name -equals $(AgentName)
    steps:
      - task: AzureCLI@2
        name: TerragruntInit
        inputs:
          azureSubscription: ${{ parameters.serviceConnection }}
          scriptType: bash
          scriptLocation: inlineScript
          addSpnToEnvironment: true
          visibleAzLogin: false
          inlineScript: |
            export ARM_CLIENT_ID=$servicePrincipalId
            export ARM_OIDC_TOKEN=$idToken
            export ARM_TENANT_ID=$tenantId
            export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
            export ARM_USE_OIDC=true
            export PIPELINE_TOKEN=$(az account get-access-token --resource 499b84ac-1321-427f-aa17-267ca6975798 --query "accessToken" --output tsv)

            instrumentation_key=$(az keyvault secret show --id https://g3scckv-cpms-mma-f07c-kv.vault.azure.net/secrets/instkey/a68523ce6abf4d77addf4cfbc247fbd1 --query value -o tsv)
            api_key=$(az keyvault secret show --id https://g3scckv-cpms-mma-f07c-kv.vault.azure.net/secrets/G3Sc-CPMS-MMahdavian-app-insights-appi-api-key/59750d02a3bc498abcf7e30d4d01e936 --query value -o tsv)

            echo "##vso[task.setvariable variable=ARMClient;issecret=true]$ARM_CLIENT_ID"
            echo "##vso[task.setvariable variable=OIDCToken;issecret=true]$ARM_OIDC_TOKEN"
            echo "##vso[task.setvariable variable=SubID;issecret=true]$ARM_SUBSCRIPTION_ID"
            echo "##vso[task.setvariable variable=TenantID;issecret=true]$ARM_TENANT_ID"
            echo "##vso[task.setvariable variable=pipelineToken;issecret=true]$PIPELINE_TOKEN"
            echo "##vso[task.setvariable variable=instrumentationKey;issecret=true]$instrumentation_key"
            echo "##vso[task.setvariable variable=apiKey;issecret=true]$api_key"


            git pull https://Azure163ent-CloudOperations:$PIPELINE_TOKEN@dev.azure.com/Azure163ent-CloudOperations/ESLZ-light_template/_git/L1_blueprint_base?ref=20241015.1
            cd $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/${{ layer }}/
            terragrunt init
      
      - task: bash@3
        name: TerragruntValidate
        inputs:
          targetType: inline
          #failOnStderr: true
          script: |
            set -e
            cd $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/${{ layer }}/
            terragrunt validate
        env:
          ARM_CLIENT_ID: $(ARMClient)
          ARM_TENANT_ID: $(TenantID)
          ARM_SUBSCRIPTION_ID: $(SubID)
          ARM_OIDC_TOKEN: $(OIDCToken)
          ARM_USE_OIDC: true
          PIPELINE_TOKEN: $(pipelineToken)

      - task: bash@3
        name: TerragruntPlan
        inputs:
          targetType: inline
          failOnStderr: false
          script: |  
            set -e       
            cd $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/${{ layer }}/
            terragrunt plan --out=$(Build.ArtifactStagingDirectory)/plan.tfplan
            terragrunt show -no-color $(Build.ArtifactStagingDirectory)/plan.tfplan > $(Build.ArtifactStagingDirectory)/plan_${{ layer }}.txt
        env:
          ARM_CLIENT_ID: $(ARMClient)
          ARM_TENANT_ID: $(TenantID)
          ARM_SUBSCRIPTION_ID: $(SubID)
          ARM_OIDC_TOKEN: $(OIDCToken)
          ARM_USE_OIDC: true
          PIPELINE_TOKEN: $(pipelineToken)
          SYSTEM_ACCESSTOKEN: $(System.AccessToken)

      - task: bash@3
        name: Checkov
        inputs: 
          targetType: inline
          script: |
            cd $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/${{ layer }}/
            terragrunt show -json $(Build.ArtifactStagingDirectory)/plan.tfplan > plan.json 
            checkov -f plan.json --skip-check ${{ parameters.checkovSkipChecks }} --quiet --soft-fail
        env:
          ARM_CLIENT_ID: $(ARMClient)
          ARM_TENANT_ID: $(TenantID)
          ARM_SUBSCRIPTION_ID: $(SubID)
          ARM_OIDC_TOKEN: $(OIDCToken)
          ARM_USE_OIDC: true
          PIPELINE_TOKEN: $(pipelineToken)

      - task: bash@3
        name: AppInsightLogs
        inputs:
          targetType: inline
          script: |
            #!/bin/bash

            function display_changes() {
              local action=$1
              jq --arg action "$action" -r '.resource_changes[] | select(.change.actions | contains([$action])) | .address' plan.json | while IFS= read -r line; do printf "%s\n" "$line"; done
            }

            # Define input parameters
            appId="$INSTRUMENTATION_KEY"
            apiKey="$API_KEY"
            eventName="Terragrunt Plan $(System.TeamProject) ${{ layer }}"
            pipelineName="$(Build.DefinitionName)"
            buildNumber="$(Build.BuildNumber)"
            org="$(System.CollectionUri)"
            project="$(System.TeamProject)"
            fullURL="$org$project"
            run="$fullURL/_build/results?buildId=$(Build.BuildId)"
            subscription_id=$(grep -Po '^\s*subscription_id\s*=\s*"\K[^"]+' $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/config.hcl)


            cd $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/${{ layer }}/
            terragrunt show -json $(Build.ArtifactStagingDirectory)/plan.tfplan > plan.json
            
            create=$(display_changes "create")
            update=$(display_changes "update")
            delete=$(display_changes "delete")

            tfOutput=$(printf "Resources that will be created:\n%s\n\nResources that will be updated:\n%s\n\nResources that will be deleted:\n%s\n" "$create" "$update" "$delete")
            

            # Set headers for the HTTP request
            headers=(
                -H "Content-Type: application/json"
                -H "X-Api-Key: $apiKey"
            )

            # Escape the newlines for JSON
            escaped_tfOutput=$(echo "$tfOutput" | jq -aRs .)

            # Set the body of the HTTP request
            body=$(jq -n \
              --arg appId "$appId" \
              --arg eventName "$eventName" \
              --arg pipelineName "$pipelineName" \
              --arg buildNumber "$buildNumber" \
              --arg subID "$subscription_id" \
              --arg project "$fullURL" \
              --arg runID "$run" \
              --arg tfOutput "$escaped_tfOutput" \
              --arg time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              '{
                name: "Microsoft.ApplicationInsights.Event",
                time: $time,
                iKey: $appId,
                data: {
                  baseType: "EventData",
                  baseData: {
                    name: $eventName,
                    properties: {
                      PipelineName: $pipelineName,
                      BuildNumber: $buildNumber,
                      subID: $subID,
                      project: $project,
                      runID: $runID,
                      TFOutput: $tfOutput | fromjson
                    }
                  }
                }
              }')

            # Define the URI for the telemetry event
            uri="https://dc.services.visualstudio.com/v2/track"

            # Make the HTTP POST request
            response=$(curl -s -X POST "${headers[@]}" -d "$body" "$uri")

            # Check if the response was successful
            if [ $? -eq 0 ]; then
              echo "Response: $response"
            else
              echo "Failed to send telemetry"
            fi
        env:
          INSTRUMENTATION_KEY: $(instrumentationKey)
          API_KEY: $(apiKey)

      - task: bash@3
        name: CommentPlanOnPR
        inputs:
          targetType: inline
          script: |
            if [ "$(Build.Reason)" == "PullRequest" ]; then
                
                cd $(agent.tempdirectory)
                echo "# Plan For ${{ parameters.eslzEnvFolder}}/${{ layer }} :" > commentplan_${{ layer }}.txt
                cat $(Build.ArtifactStagingDirectory)/plan_${{ layer }}.txt >> commentplan_${{ layer }}.txt
                ENCODED_URL=$(echo "${SYSTEM_COLLECTIONURI}${SYSTEM_TEAMPROJECT}/_apis/git/repositories/${BUILD_REPOSITORYID}/pullRequests/${SYSTEM_PULLREQUEST_PULLREQUESTID}/threads?api-version=7.1-preview.1" | sed 's/ /%20/g')
                COMMENT_JSON=$(jq --rawfile comment commentplan_${{ layer }}.txt '.comments[0].content=$comment' <<< '{"comments": [{"parentCommentId": 0,"content": "","commentType": 1}],"status": 1}')
            
                echo "POSTING TO $ENCODED_URL"
                curl "$ENCODED_URL" \
                --header "Content-Type: application/json" \
                --header "Accept: application/json" \
                --header "Authorization: Bearer $SYSTEM_ACCESSTOKEN" \
                --data "$COMMENT_JSON" \
                --verbose
            else
                echo "Skipping post comment due to no pull request"
            fi
        env:
          SYSTEM_ACCESSTOKEN: $(System.AccessToken)
          SYSTEM_COLLECTIONURI: $(System.CollectionUri)
          SYSTEM_TEAMPROJECT: $(System.TeamProject)
          BUILD_REPOSITORYID: $(Build.Repository.ID)
          SYSTEM_PULLREQUEST_PULLREQUESTID: $(System.PullRequest.PullRequestId)

      - task: PublishBuildArtifacts@1
        name: PublishPlan
        inputs:
          PathtoPublish: $(Build.ArtifactStagingDirectory)
          ArtifactName: plan_${{ parameters.eslzEnvFolder}}_${{ layer }}
      
      - task: PublishBuildArtifacts@1
        name: PublishTF
        inputs:
          PathtoPublish: $(Build.SourcesDirectory)
          ArtifactName: tf_${{ parameters.eslzEnvFolder }}_${{ layer }}
      