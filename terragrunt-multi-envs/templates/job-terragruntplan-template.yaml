parameters:
  - name: layers
    type: object
  - name: serviceConnection
    type: string
  - name: eslzEnvFolder
    type: string
  - name: checkovSkipChecks
    type: string
  - name: eslzEnvPool
    type: string


jobs:
- ${{ each layer in parameters.layers }}:  
  - job: TerragruntPlan_${{ parameters.eslzEnvFolder}}_${{ layer }}
    dependsOn: InitJob
    condition: and(succeeded(), eq(dependencies.InitJob.outputs['GitDiffTask.RepoChange${{ layer }}'], 'true'))
    variables:
      AgentName: $[ dependencies.InitJob.outputs['TFTGInstall.JobAgentName'] ]
    pool: 
      name: ${{ parameters.eslzEnvPool }}
      demands: Agent.Name -equals $(AgentName)
    steps:
      - task: AzureCLI@2
        name: TerragruntInit
        inputs:
          azureSubscription: ${{ parameters.serviceConnection }}
          scriptType: bash
          scriptLocation: inlineScript
          addSpnToEnvironment: true
          inlineScript: |
            export ARM_CLIENT_ID=$servicePrincipalId
            export ARM_OIDC_TOKEN=$idToken
            export ARM_TENANT_ID=$tenantId
            export ARM_SUBSCRIPTION_ID=$(az account show --query id -o tsv)
            export ARM_USE_OIDC=true
            export PIPELINE_TOKEN=$(az account get-access-token --resource 499b84ac-1321-427f-aa17-267ca6975798 --query "accessToken" --output tsv)

            echo "##vso[task.setvariable variable=ARMClient;issecret=true]$ARM_CLIENT_ID"
            echo "##vso[task.setvariable variable=OIDCToken;issecret=true]$ARM_OIDC_TOKEN"
            echo "##vso[task.setvariable variable=SubID;issecret=true]$ARM_SUBSCRIPTION_ID"
            echo "##vso[task.setvariable variable=TenantID;issecret=true]$ARM_TENANT_ID"
            echo "##vso[task.setvariable variable=pipelineToken;issecret=true]$PIPELINE_TOKEN"

            cd $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/${{ layer }}/
            terragrunt init
      
      - task: bash@3
        name: TerragruntValidate
        inputs:
          targetType: inline
          script: |
            cd $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/${{ layer }}/
            terragrunt validate
        env:
          ARM_CLIENT_ID: $(ARMClient)
          ARM_TENANT_ID: $(TenantID)
          ARM_SUBSCRIPTION_ID: $(SubID)
          ARM_OIDC_TOKEN: $(OIDCToken)
          ARM_USE_OIDC: true
          PIPELINE_TOKEN: $(pipelineToken)

      - task: bash@3
        name: TerragruntPlan
        inputs:
          targetType: inline
          script: |         
            cd $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/${{ layer }}/
            terragrunt plan -detailed-exitcode --out=$(Build.ArtifactStagingDirectory)/plan.tfplan
            terragrunt show -no-color $(Build.ArtifactStagingDirectory)/plan.tfplan > $(Build.ArtifactStagingDirectory)/plan_${{ layer }}.txt
        env:
          ARM_CLIENT_ID: $(ARMClient)
          ARM_TENANT_ID: $(TenantID)
          ARM_SUBSCRIPTION_ID: $(SubID)
          ARM_OIDC_TOKEN: $(OIDCToken)
          ARM_USE_OIDC: true
          PIPELINE_TOKEN: $(pipelineToken)

      - task: bash@3
        name: Checkov
        inputs: 
          targetType: inline
          script: |
            cd $(Build.SourcesDirectory)/landing_zones_*/${{ parameters.eslzEnvFolder}}/${{ layer }}/
            terragrunt show -json $(Build.ArtifactStagingDirectory)/plan.tfplan > plan.json 
            checkov -f plan.json --skip-check ${{ parameters.checkovSkipChecks }} --quiet
        env:
          ARM_CLIENT_ID: $(ARMClient)
          ARM_TENANT_ID: $(TenantID)
          ARM_SUBSCRIPTION_ID: $(SubID)
          ARM_OIDC_TOKEN: $(OIDCToken)
          ARM_USE_OIDC: true
          PIPELINE_TOKEN: $(pipelineToken)

      - task: bash@3
        name: AppInsightsLogs
        inputs:
          targetType: inline
          # arguments: '$(APP_INSIGHTS_INSTRUMENTATION_KEY) $(APP_INSIGHTS_API_KEY) "Terragrunt Init" "$(Build.DefinitionName)" "$(Build.BuildNumber)"'
          script: |
            #!/bin/bash

            # Define input parameters
            appId='InstrumentationKey=1591046f-42fa-40d8-9cf0-126e5baf826b;IngestionEndpoint=https://canadacentral-1.in.applicationinsights.azure.com/;LiveEndpoint=https://canadacentral.livediagnostics.monitor.azure.com/;ApplicationId=d08f3308-52f7-44de-95b4-d7d979beb63c'
            apiKey='$(APP_INSIGHTS_API_KEY)'
            eventName="Terragrunt Init"
            pipelineName="$(Build.DefinitionName)"
            buildNumber="$(Build.BuildNumber)"
            status=$6

            # Set headers for the HTTP request
            headers=(
                -H "Content-Type: application/json"
                -H "X-Api-Key: $apiKey"
            )

            # Set the body of the HTTP request
            body=$(jq -n \
              --arg appId "$appId" \
              --arg eventName "$eventName" \
              --arg pipelineName "$pipelineName" \
              --arg buildNumber "$buildNumber" \
              --arg time "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              '{
                name: "Microsoft.ApplicationInsights.Event",
                time: $time,
                iKey: $appId,
                data: {
                  baseType: "EventData",
                  baseData: {
                    name: $eventName,
                    properties: {
                      PipelineName: $pipelineName,
                      BuildNumber: $buildNumber,
                      # Status: $status
                    }
                  }
                }
              }')

            # Define the URI for the telemetry event
            uri="https://dc.services.visualstudio.com/v2/track"

            # Make the HTTP POST request
            response=$(curl -s -X POST "${headers[@]}" -d "$body" "$uri")

            # Check if the response was successful
            if [ $? -eq 0 ]; then
              echo "Response: $response"
            else
              echo "Failed to send telemetry"
            fi
          
      - task: bash@3
        name: CommentPlanOnPR
        inputs:
          targetType: inline
          script: |
            if [ "$(Build.Reason)" == "PullRequest" ]; then
                
                cd $(agent.tempdirectory)
                echo "# Plan For ${{ parameters.eslzEnvFolder}}/${{ layer }} :" > commentplan_${{ layer }}.txt
                cat $(Build.ArtifactStagingDirectory)/plan_${{ layer }}.txt >> commentplan_${{ layer }}.txt
                ENCODED_URL=$(echo "${SYSTEM_COLLECTIONURI}${SYSTEM_TEAMPROJECT}/_apis/git/repositories/${BUILD_REPOSITORYID}/pullRequests/${SYSTEM_PULLREQUEST_PULLREQUESTID}/threads?api-version=7.1-preview.1" | sed 's/ /%20/g')
                COMMENT_JSON=$(jq --rawfile comment commentplan_${{ layer }}.txt '.comments[0].content=$comment' <<< '{"comments": [{"parentCommentId": 0,"content": "","commentType": 1}],"status": 1}')
            
                echo "POSTING TO $ENCODED_URL"
                curl "$ENCODED_URL" \
                --header "Content-Type: application/json" \
                --header "Accept: application/json" \
                --header "Authorization: Bearer $SYSTEM_ACCESSTOKEN" \
                --data "$COMMENT_JSON" \
                --verbose
            else
                echo "Skipping post comment due to no pull request"
            fi
        env:
          SYSTEM_ACCESSTOKEN: $(System.AccessToken)
          SYSTEM_COLLECTIONURI: $(System.CollectionUri)
          SYSTEM_TEAMPROJECT: $(System.TeamProject)
          BUILD_REPOSITORYID: $(Build.Repository.ID)
          SYSTEM_PULLREQUEST_PULLREQUESTID: $(System.PullRequest.PullRequestId)

      - task: PublishBuildArtifacts@1
        name: PublishPlan
        inputs:
          PathtoPublish: $(Build.ArtifactStagingDirectory)
          ArtifactName: plan_${{ parameters.eslzEnvFolder}}_${{ layer }}
      
      - task: PublishBuildArtifacts@1
        name: PublishTF
        inputs:
          PathtoPublish: $(Build.SourcesDirectory)
          ArtifactName: tf_${{ parameters.eslzEnvFolder }}_${{ layer }}
      